// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";
import * as Stdlib__Format from "melange/format.js";
import * as Stdlib__Int32 from "melange/int32.js";
import * as Stdlib__Int64 from "melange/int64.js";
import * as Stdlib__List from "melange/list.js";
import * as Stdlib__Map from "melange/map.js";
import * as Stdlib__String from "melange/string.js";

function split_path(target) {
  var split_target = function (target) {
    switch (target) {
      case "" :
      case "/" :
          return /* [] */0;
      default:
        var xs = Stdlib__String.split_on_char(/* '/' */47, target);
        if (xs && xs.hd === "") {
          return xs.tl;
        } else {
          return xs;
        }
    }
  };
  var i = Stdlib__String.index_opt(target, /* '?' */63);
  if (i !== undefined) {
    if (i !== 0) {
      return split_target(Stdlib__String.sub(target, 0, i));
    } else {
      return /* [] */0;
    }
  } else {
    return split_target(target);
  }
}

var KeyMap = Stdlib__Map.Make({
      compare: Stdlib__String.compare
    });

var empty_children = KeyMap.empty;

var empty = {
  parsers: /* [] */0,
  children: empty_children,
  capture: undefined,
  wildcard: false
};

function feed_params(t, params) {
  var _t = t;
  var _params = params;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var params$1 = _params;
    var t$1 = _t;
    if (!params$1) {
      return acc;
    }
    if (params$1.hd === "" && !params$1.tl) {
      return acc;
    }
    var xs = params$1.tl;
    var capture = t$1.capture;
    var m$p = Curry._2(KeyMap.find_opt, params$1.hd, t$1.children);
    if (m$p !== undefined) {
      _acc = Stdlib.$at(m$p.parsers, acc);
      _params = xs;
      _t = m$p;
      continue ;
    }
    if (capture === undefined) {
      return /* [] */0;
    }
    _acc = Stdlib.$at(capture.parsers, acc);
    _params = xs;
    _t = capture;
    continue ;
  };
}

function add(k, v, t) {
  var aux = function (k, t) {
    if (!k) {
      return {
              parsers: {
                hd: v,
                tl: t.parsers
              },
              children: t.children,
              capture: t.capture,
              wildcard: t.wildcard
            };
    }
    var capture = t.capture;
    var children = t.children;
    var r = k.tl;
    var x = k.hd;
    if (typeof x === "number") {
      if (x) {
        return {
                parsers: {
                  hd: v,
                  tl: t.parsers
                },
                children: t.children,
                capture: t.capture,
                wildcard: true
              };
      }
      var t$p = capture !== undefined ? capture : empty;
      var t$p$p = aux(r, t$p);
      return {
              parsers: t.parsers,
              children: t.children,
              capture: t$p$p,
              wildcard: t.wildcard
            };
    }
    var w = x._0;
    var v$1 = Curry._2(KeyMap.find_opt, w, children);
    var t$p$1 = v$1 !== undefined ? v$1 : empty;
    var t$p$p$1 = aux(r, t$p$1);
    return {
            parsers: t.parsers,
            children: Curry._3(KeyMap.add, w, t$p$p$1, children),
            capture: t.capture,
            wildcard: t.wildcard
          };
  };
  return aux(k, t);
}

function union(t1, t2) {
  var parsers = Stdlib.$at(t1.parsers, t2.parsers);
  var children = Curry._3(KeyMap.merge, (function (param, l, r) {
          if (l !== undefined) {
            if (r !== undefined) {
              return union(l, r);
            } else {
              return l;
            }
          }
          if (r !== undefined) {
            return r;
          }
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "routes_multi.ml",
                  77,
                  26
                ],
                Error: new Error()
              };
        }), t1.children, t2.children);
  var match = t1.capture;
  var match$1 = t2.capture;
  var capture = match !== undefined ? (
      match$1 !== undefined ? union(match, match$1) : match
    ) : (
      match$1 !== undefined ? match$1 : undefined
    );
  var match$2 = t1.wildcard;
  var match$3 = t2.wildcard;
  var wildcard = match$2 ? (
      match$3 ? true : Stdlib.failwith("Attemp to union wildcard and non-wildcard pattern")
    ) : (
      match$3 ? Stdlib.failwith("Attemp to union wildcard and non-wildcard pattern") : false
    );
  return {
          parsers: parsers,
          children: children,
          capture: capture,
          wildcard: wildcard
        };
}

function of_parts(x) {
  return {
          prefix: /* [] */0,
          matched: split_path(x)
        };
}

function wildcard_match(t) {
  return Stdlib__String.concat("/", {
              hd: "",
              tl: t.matched
            });
}

function prefix(t) {
  return Stdlib__String.concat("/", {
              hd: "",
              tl: t.prefix
            });
}

function pattern(to_, from_, label, r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: to_,
            from_: from_,
            label: label
          },
          _1: r
        };
}

function custom(to_, from_, label, r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: to_,
            from_: from_,
            label: label
          },
          _1: r
        };
}

function $at$neg$neg$great(r, handler) {
  return /* Route */{
          _0: r,
          _1: handler,
          _2: (function (x) {
              return x;
            })
        };
}

function route(r, handler) {
  return /* Route */{
          _0: r,
          _1: handler,
          _2: (function (x) {
              return x;
            })
        };
}

function s(w, r) {
  return {
          TAG: /* Match */0,
          _0: w,
          _1: r
        };
}

function $$int(r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: (function (prim) {
                return String(prim);
              }),
            from_: Stdlib.int_of_string_opt,
            label: ":int"
          },
          _1: r
        };
}

function int64(r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: Stdlib__Int64.to_string,
            from_: Stdlib__Int64.of_string_opt,
            label: ":int64"
          },
          _1: r
        };
}

function int32(r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: Stdlib__Int32.to_string,
            from_: Stdlib__Int32.of_string_opt,
            label: ":int32"
          },
          _1: r
        };
}

function str(r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: (function (x) {
                return x;
              }),
            from_: (function (x) {
                return x;
              }),
            label: ":string"
          },
          _1: r
        };
}

function bool(r) {
  return {
          TAG: /* Conv */1,
          _0: {
            to_: Stdlib.string_of_bool,
            from_: Stdlib.bool_of_string_opt,
            label: ":bool"
          },
          _1: r
        };
}

function $slash(m1, m2, r) {
  return Curry._1(m1, Curry._1(m2, r));
}

function $slash$question(m1, m2) {
  return Curry._1(m1, m2);
}

function route_pattern(param) {
  if (typeof param === "number") {
    if (param === /* End */0) {
      return /* [] */0;
    } else {
      return {
              hd: /* Wildcard */1,
              tl: /* [] */0
            };
    }
  } else if (param.TAG === /* Match */0) {
    return {
            hd: /* Match */{
              _0: param._0
            },
            tl: route_pattern(param._1)
          };
  } else {
    return {
            hd: /* Capture */0,
            tl: route_pattern(param._1)
          };
  }
}

function pp_path$p(path) {
  var aux = function (param) {
    if (typeof param === "number") {
      if (param === /* End */0) {
        return /* [] */0;
      } else {
        return {
                hd: ":wildcard",
                tl: /* [] */0
              };
      }
    } else if (param.TAG === /* Match */0) {
      return {
              hd: param._0,
              tl: aux(param._1)
            };
    } else {
      return {
              hd: param._0.label,
              tl: aux(param._1)
            };
    }
  };
  return aux(path);
}

function pp_target(fmt, t) {
  Curry._1(Stdlib__Format.fprintf(fmt)(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), "/" + Stdlib__String.concat("/", pp_path$p(t)));
}

function string_of_path(t) {
  return Curry._2(Stdlib__Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  },
                  _1: "%a"
                }), pp_target, t);
}

function pp_route(fmt, param) {
  pp_target(fmt, param._0);
}

function string_of_route(r) {
  return Curry._2(Stdlib__Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  },
                  _1: "%a"
                }), pp_route, r);
}

function ksprintf(k, t) {
  var k$1 = function (x) {
    return Curry._1(k, "/" + Stdlib__String.concat("/", x));
  };
  var aux = function (_k, _param) {
    while(true) {
      var param = _param;
      var k = _k;
      if (typeof param === "number") {
        if (param === /* End */0) {
          return Curry._1(k, /* [] */0);
        } else {
          return (function(k){
          return function (param) {
            return Curry._1(k, Stdlib__List.concat({
                            hd: param.matched,
                            tl: {
                              hd: /* [] */0,
                              tl: /* [] */0
                            }
                          }));
          }
          }(k));
        }
      }
      if (param.TAG === /* Match */0) {
        var w = param._0;
        _param = param._1;
        _k = (function(k,w){
        return function (s) {
          return Curry._1(k, {
                      hd: w,
                      tl: s
                    });
        }
        }(k,w));
        continue ;
      }
      var fmt = param._1;
      var to_ = param._0.to_;
      return (function(k,to_,fmt){
      return function (x) {
        return aux((function (rest) {
                      return Curry._1(k, {
                                  hd: Curry._1(to_, x),
                                  tl: rest
                                });
                    }), fmt);
      }
      }(k,to_,fmt));
    };
  };
  return aux(k$1, t);
}

function sprintf(t) {
  return ksprintf((function (x) {
                return x;
              }), t);
}

function parse_route(path, handler, params) {
  var _t = path;
  var _f = handler;
  var _seen = /* [] */0;
  var _s = params;
  while(true) {
    var s = _s;
    var seen = _seen;
    var f = _f;
    var t = _t;
    if (typeof t === "number") {
      if (t === /* End */0) {
        if (s && !(s.hd === "" && !s.tl)) {
          return /* NoMatch */0;
        } else {
          return /* FullMatch */{
                  _0: {
                    hd: f,
                    tl: /* [] */0
                  }
                };
        }
      } else {
        return /* FullMatch */{
                _0: {
                  hd: Curry._1(f, {
                        prefix: Stdlib__List.rev(seen),
                        matched: s
                      }),
                  tl: /* [] */0
                }
              };
      }
    }
    if (t.TAG === /* Match */0) {
      if (!s) {
        return /* NoMatch */0;
      }
      var x$p = s.hd;
      if (t._0 !== x$p) {
        return /* NoMatch */0;
      }
      _s = s.tl;
      _seen = {
        hd: x$p,
        tl: seen
      };
      _t = t._1;
      continue ;
    }
    if (!s) {
      return /* NoMatch */0;
    }
    var x = s.hd;
    var x$p$1 = Curry._1(t._0.from_, x);
    if (x$p$1 === undefined) {
      return /* NoMatch */0;
    }
    _s = s.tl;
    _seen = {
      hd: x,
      tl: seen
    };
    _f = Curry._1(f, Caml_option.valFromOption(x$p$1));
    _t = t._1;
    continue ;
  };
}

function one_of(routes) {
  var routes$1 = Stdlib__List.rev(routes);
  return Stdlib__List.fold_left((function (routes, route) {
                var patterns = route_pattern(route._0);
                return add(patterns, route, routes);
              }), empty, routes$1);
}

function add_route(route, routes) {
  var patterns = route_pattern(route._0);
  return add(patterns, route, routes);
}

function map(f, param) {
  var g = param._2;
  return /* Route */{
          _0: param._0,
          _1: param._1,
          _2: (function (x) {
              return Curry._1(f, Curry._1(g, x));
            })
        };
}

function match$p(router, target) {
  var target$1 = split_path(target);
  var routes = feed_params(router, target$1);
  var _routes = routes;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var routes$1 = _routes;
    if (!routes$1) {
      return /* FullMatch */{
              _0: acc
            };
    }
    var rs = routes$1.tl;
    var match = routes$1.hd;
    var r = parse_route(match._0, match._1, target$1);
    if (r) {
      var r$1 = Stdlib__List.map(match._2, r._0);
      _acc = Stdlib.$at(r$1, acc);
      _routes = rs;
      continue ;
    }
    _routes = rs;
    continue ;
  };
}

function $slash$tilde(m, path) {
  return Curry._1(m, path);
}

var Parts = {
  prefix: prefix,
  wildcard_match: wildcard_match,
  of_parts: of_parts
};

var wildcard = /* Wildcard */1;

var nil = /* End */0;

export {
  Parts ,
  $$int ,
  int32 ,
  int64 ,
  str ,
  bool ,
  s ,
  wildcard ,
  nil ,
  pattern ,
  custom ,
  $slash ,
  $slash$tilde ,
  $slash$question ,
  $at$neg$neg$great ,
  route ,
  one_of ,
  map ,
  match$p ,
  ksprintf ,
  sprintf ,
  pp_target ,
  pp_route ,
  string_of_path ,
  string_of_route ,
  add_route ,
  union ,
}
/* KeyMap Not a pure module */
